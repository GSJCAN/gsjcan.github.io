<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[阿贝-波特实验]]></title>
      <url>http://gsjcan.com/2017/05/13/%E9%98%BF%E8%B4%9D-%E6%B3%A2%E7%89%B9%E5%AE%9E%E9%AA%8C/</url>
      <content type="html"><![CDATA[<p><img src="http://omwttm1sr.bkt.clouddn.com/%E9%98%BF%E8%B4%9D-%E6%B3%A2%E7%89%B9%E5%AE%9E%E9%AA%8C_%E9%A1%B5%E9%9D%A2_1.jpg" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E9%98%BF%E8%B4%9D-%E6%B3%A2%E7%89%B9%E5%AE%9E%E9%AA%8C_%E9%A1%B5%E9%9D%A2_2.jpg" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E9%98%BF%E8%B4%9D-%E6%B3%A2%E7%89%B9%E5%AE%9E%E9%AA%8C_%E9%A1%B5%E9%9D%A2_3.jpg" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E9%98%BF%E8%B4%9D-%E6%B3%A2%E7%89%B9%E5%AE%9E%E9%AA%8C_%E9%A1%B5%E9%9D%A2_4.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 近代物理实验 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 实验报告 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[英语翻译中的四字词语]]></title>
      <url>http://gsjcan.com/2017/04/15/%E8%8B%B1%E8%AF%AD%E7%BF%BB%E8%AF%91%E4%B8%AD%E7%9A%84%E5%9B%9B%E5%AD%97%E8%AF%8D%E8%AF%AD/</url>
      <content type="html"><![CDATA[<h2 id="四字词语"><a href="#四字词语" class="headerlink" title="四字词语"></a>四字词语</h2><p>e.g.<br>少数民族：minority<br>节日活动：festivity<br>隆重喜庆：jubilant and important<br>年画窗花： paper-cuts<br>灯火齐明：all brigghtly lit<br>辞旧守岁：bid farewell to the outgoing year and stay up late or all night</p>
<blockquote>
<p>汉语四字结构的关系有三种：并列(co-ordinate)关系、偏正(modifying)关系、主谓(subject-predicate)关系。</p>
</blockquote>
<p>一、并列关系<br>安定团结:stability and unity<br>美丽善良:kind-hearted and beautiful<br>干净整齐:clean and tidy<br>典雅大方:elegant and graceful<br>轻松柔软:soft and light<br>送旧迎新:to set off the old and welcome the new<br>改革开放:reform and opening up<br>丰衣足食:well-fed and well clothed</p>
<blockquote>
<p>有时候，并列关系的四字结构实际上是同义重复，汉语中往往是加强语势，翻译时只需要翻译一个即可。</p>
</blockquote>
<p>生动活泼:lively<br>光辉灿烂:brilliant<br>打击报复:retaliate<br>繁荣昌盛:prosperous<br>添油加醋:to add spice to<br>断章取义:to quote out of context<br>贼眉鼠眼:shifty-eyed (thievish-looking)<br>声嘶力竭:to shout oneself hoarse<br>丰功伟绩:great achievements<br>心灰意懒:To feel disheartened<br>穷山恶水:Poverty-stricken places; barren hills and untamed rivers<br>称心如意:satisfactory<br>惊天动地:earth-shaking<br>穷凶极恶:nefarious<br>唉声叹气:moan and groan<br>胡言乱语:talk nonsense<br>奇装异服:outlandish clothes<br>南腔北调:a mixed accent<br>日新月异:ever changing<br>粗制滥造:crudely made<br>深仇大恨:deep hatred<br>奇谈怪论:strange tale<br>千方百计:by hook or crook<br>街谈巷议:street gossip</p>
<p>二、偏正关系<br>市场机制:market mechanism<br>合资企业:joint venture<br>达成协议:to reach an agreement<br>平等会谈:the talk on an equal footing<br>连年丰收:bumper harvest for years running<br>稳定物价:to stabilize commodity prices<br>上缴利税:financial contribution to the government revenues<br>大补元气:to reinforce vital energy</p>
<p>三、主谓关系<br>质量第一:quality first<br>用户至上:customer first<br>布局合理:rational distribution<br>全面发展:all-round devolopment<br>工业发展:expanding industry<br>人民生活:people`s life<br>门类齐全:complete in range<br>结构合理:rational in structure<br>水域宽阔,水深浪静:a vast expanse of deep and peaceful seawater<br>通行无阻:enter or leave with ease</p>
<p>四、常用四字结构翻译<br>质地优良:be excellent in quality/ with superior quality<br>品种齐全:in complete range of articles<br>款式繁多:with various patterns<br>选料考究:choiced materials<br>做工精细:fine workmanship<br>色泽鲜明:bright-colured<br>零售/批发价格:retail/wholesale price<br>货到付款:payment against arrival<br>名牌产品:name brand product<br>拳头产品:knock-out product<br>出类拔萃:above average<br>驰名中外:be popular both at home and abroad<br>久负盛名:with a long standing reputation<br>万古流芳:will be remembered throughout the age<br>名垂青史:to go down in history<br>家喻户晓:be widely known<br>倾国倾城:exceedingly beautiful<br>欢迎订购:Orders are welcome.<br>工业园区:industrial park<br>产权转让:property-right exchange / transfer<br>土地租赁:land lease<br>资产评估:appraise one’s assets<br>国有资产:state assets<br>无形资产:intangible assets<br>优化结构:to optimize the structure of production<br>购售政策:the purchase-market policy<br>扭亏为盈:to reduce losses and increase profits<br>增进效益:to increase economic returns<br>暂行条例:interim regulations<br>廉洁自律:to perform one’s duty honestly<br>事倍功半:efforts doubled, result halved<br>天长地久:as long as the hills<br>德才兼备:with both professional abilities and political integrity<br>开拓进取:to work hard with a pioneering spirit<br>投资热点:investment hot spot<br>经济特区:special economic zone<br>物价指数:price-rise index<br>税费改革:reform of taxes and charges<br>对口援助:unit-to-unit aid programme<br>社会办学:non-governmental schools<br>牟取暴利:price hikes for exorbitant profits<br>合法权益:lawful right and interest<br>事半功倍:efforts halved, result doubled<br>安居乐业:live in peace and work in contentment<br>奔走相告:running around to spread the news<br>不务正业:not engaged in the right business<br>叱咤风云:command wind and cloud; extremely powerful or influential<br>大相径庭:totally different<br>处心积虑:rack one’s brain to scheme<br>固若金汤:(of a city) so impregnable as if made up of gold and surrounded by a river with boiling water; strongly fortified; impregnable<br>疾恶如仇:extremely hateful of evils<br>进退两难:be torn between advancing and retreating; be in a dilemma</p>
<h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><p>腊月:the 12th lunar month<br>对联:couplets on red paper<br>启朱唇:open one’s vermilion lips<br>发皓齿:display one’s sparking white teeth<br>降噪音:noise reduction(volume)<br>版权税:royalty<br>打砸抢:beating , smashing and looting<br>中国民航:Air China<br>知识产权:intellectual property(right)<br>海关总署:the Custom Service<br>证券交易所:stock exchange<br>产权交易所:property right exchange<br>国家出版局:the State Copyright Administration<br>农林牧副渔:farming,forestry,animal husbandry,side-line production and fishery<br>中国国际广播公司:Radio Beijing<br>国家工商行政管理局:the State Administration of Industry and Commerce<br>高等教育研究生:Higher Education Institute<br>省电、噪音小、造型美:less power consumption,negligible noise,attractive appearance<br>出口经营权审批制度:the examination and approval system for exporting rights<br>出口经营登记备案制度:a registration and recording system for the right to export<br>会计信息质量抽查公告制度:the system for publicizing the results of random inspections of the quality of accounting information<br>职业资格证书制度:the professional qualification certificate system;<br>the system to issue professional qualification certificates<br>责任追究制度:the system of accountability<br>预算外资金:extrabudgetary funds<br>中央／地方财政预算:the central and local budgets<br>财政赤字:financial<br>堤内损失堤外补:gain on the swings what is lost on the roundabouts<br>转移支付:transfer payments;transferred payments<br>发展经济，开辟财源:development of economy and opening up new revenue resources<br>关于调整和控制投资结构的政策:policies concerned with regulating and restructuring investment<br>地震学会:Seismological Society<br>国际金融学会:International Finance Society<br>国际战略问题学会:Institute for International Strategic Studies<br>中国佛教协会:Chinese Buddhists Association<br>中国福利会:China Welfare Institute<br>中国歌剧研究会:Chinese Opera Research Institute<br>中华全国体育总会:All-China Sports Federation<br>中华全国新闻工作者协会:All-China Journalists’ Association;<br>中华全国总工会:All-China Federation of Trade Union;<br>中华医学会:Chinese Medical Association</p>
]]></content>
      
        <categories>
            
            <category> English Learning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 翻译；四字词语 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[氢原子光谱]]></title>
      <url>http://gsjcan.com/2017/04/11/%E6%B0%A2%E5%8E%9F%E5%AD%90%E5%85%89%E8%B0%B1/</url>
      <content type="html"><![CDATA[<p><img src="http://omwttm1sr.bkt.clouddn.com/%E6%B0%A2%E5%8E%9F%E5%AD%90%E5%85%89%E8%B0%B1_%E9%A1%B5%E9%9D%A2_01.png" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E6%B0%A2%E5%8E%9F%E5%AD%90%E5%85%89%E8%B0%B1_%E9%A1%B5%E9%9D%A2_02.png" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E6%B0%A2%E5%8E%9F%E5%AD%90%E5%85%89%E8%B0%B1_%E9%A1%B5%E9%9D%A2_03.png" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E6%B0%A2%E5%8E%9F%E5%AD%90%E5%85%89%E8%B0%B1_%E9%A1%B5%E9%9D%A2_04.png" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E6%B0%A2%E5%8E%9F%E5%AD%90%E5%85%89%E8%B0%B1_%E9%A1%B5%E9%9D%A2_05.png" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E6%B0%A2%E5%8E%9F%E5%AD%90%E5%85%89%E8%B0%B1_%E9%A1%B5%E9%9D%A2_06.png" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E6%B0%A2%E5%8E%9F%E5%AD%90%E5%85%89%E8%B0%B1_%E9%A1%B5%E9%9D%A2_07.png" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E6%B0%A2%E5%8E%9F%E5%AD%90%E5%85%89%E8%B0%B1_%E9%A1%B5%E9%9D%A2_08.png" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E6%B0%A2%E5%8E%9F%E5%AD%90%E5%85%89%E8%B0%B1_%E9%A1%B5%E9%9D%A2_09.png" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E6%B0%A2%E5%8E%9F%E5%AD%90%E5%85%89%E8%B0%B1_%E9%A1%B5%E9%9D%A2_10.png" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E6%B0%A2%E5%8E%9F%E5%AD%90%E5%85%89%E8%B0%B1_%E9%A1%B5%E9%9D%A2_11.png" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E6%B0%A2%E5%8E%9F%E5%AD%90%E5%85%89%E8%B0%B1_%E9%A1%B5%E9%9D%A2_12.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 近代物理实验 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 实验报告 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[塞曼效应]]></title>
      <url>http://gsjcan.com/2017/04/04/%E5%A1%9E%E6%9B%BC%E6%95%88%E5%BA%94/</url>
      <content type="html"><![CDATA[<p><img src="http://omwttm1sr.bkt.clouddn.com/%E5%A1%9E%E6%9B%BC%E6%95%88%E5%BA%94_%E9%A1%B5%E9%9D%A2_01.jpg" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E5%A1%9E%E6%9B%BC%E6%95%88%E5%BA%94_%E9%A1%B5%E9%9D%A2_02.jpg" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E5%A1%9E%E6%9B%BC%E6%95%88%E5%BA%94_%E9%A1%B5%E9%9D%A2_03.jpg" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E5%A1%9E%E6%9B%BC%E6%95%88%E5%BA%94_%E9%A1%B5%E9%9D%A2_04.jpg" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E5%A1%9E%E6%9B%BC%E6%95%88%E5%BA%94_%E9%A1%B5%E9%9D%A2_05.jpg" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E5%A1%9E%E6%9B%BC%E6%95%88%E5%BA%94_%E9%A1%B5%E9%9D%A2_06.jpg" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E5%A1%9E%E6%9B%BC%E6%95%88%E5%BA%94_%E9%A1%B5%E9%9D%A2_07.jpg" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E5%A1%9E%E6%9B%BC%E6%95%88%E5%BA%94_%E9%A1%B5%E9%9D%A2_08.jpg" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E5%A1%9E%E6%9B%BC%E6%95%88%E5%BA%94_%E9%A1%B5%E9%9D%A2_09.jpg" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E5%A1%9E%E6%9B%BC%E6%95%88%E5%BA%94_%E9%A1%B5%E9%9D%A2_10.jpg" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E5%A1%9E%E6%9B%BC%E6%95%88%E5%BA%94_%E9%A1%B5%E9%9D%A2_11.jpg" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E5%A1%9E%E6%9B%BC%E6%95%88%E5%BA%94_%E9%A1%B5%E9%9D%A2_12.jpg" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E5%A1%9E%E6%9B%BC%E6%95%88%E5%BA%94_%E9%A1%B5%E9%9D%A2_13.jpg" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E5%A1%9E%E6%9B%BC%E6%95%88%E5%BA%94_%E9%A1%B5%E9%9D%A2_14.jpg" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E5%A1%9E%E6%9B%BC%E6%95%88%E5%BA%94_%E9%A1%B5%E9%9D%A2_15.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 近代物理实验 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 实验报告 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[夫兰克赫兹实验]]></title>
      <url>http://gsjcan.com/2017/03/27/%E5%A4%AB%E5%85%B0%E5%85%8B%E8%B5%AB%E5%85%B9%E5%AE%9E%E9%AA%8C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
      <content type="html"><![CDATA[<p>接下来会把一下个人认为比较好的几份实验报告贴上过来。</p>
<p>因为不太想用markdown再写一遍，所以就把.PDF转成.PNG直接以图片形式放上来了。凑合看……</p>
<p><img src="http://i2.muimg.com/567571/242c785081355ce6.png" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E5%A4%AB%E5%85%B0%E5%85%8B%E8%B5%AB%E5%85%B9%E5%AE%9E%E9%AA%8C_%E9%A1%B5%E9%9D%A2_03.png" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E5%A4%AB%E5%85%B0%E5%85%8B%E8%B5%AB%E5%85%B9%E5%AE%9E%E9%AA%8C_%E9%A1%B5%E9%9D%A2_04.png" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E5%A4%AB%E5%85%B0%E5%85%8B%E8%B5%AB%E5%85%B9%E5%AE%9E%E9%AA%8C_%E9%A1%B5%E9%9D%A2_05.png" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E5%A4%AB%E5%85%B0%E5%85%8B%E8%B5%AB%E5%85%B9%E5%AE%9E%E9%AA%8C_%E9%A1%B5%E9%9D%A2_06.png" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E5%A4%AB%E5%85%B0%E5%85%8B%E8%B5%AB%E5%85%B9%E5%AE%9E%E9%AA%8C_%E9%A1%B5%E9%9D%A2_07.png" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E5%A4%AB%E5%85%B0%E5%85%8B%E8%B5%AB%E5%85%B9%E5%AE%9E%E9%AA%8C_%E9%A1%B5%E9%9D%A2_08.png" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E5%A4%AB%E5%85%B0%E5%85%8B%E8%B5%AB%E5%85%B9%E5%AE%9E%E9%AA%8C_%E9%A1%B5%E9%9D%A2_09.png" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E5%A4%AB%E5%85%B0%E5%85%8B%E8%B5%AB%E5%85%B9%E5%AE%9E%E9%AA%8C_%E9%A1%B5%E9%9D%A2_10.png" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E5%A4%AB%E5%85%B0%E5%85%8B%E8%B5%AB%E5%85%B9%E5%AE%9E%E9%AA%8C_%E9%A1%B5%E9%9D%A2_11.png" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E5%A4%AB%E5%85%B0%E5%85%8B%E8%B5%AB%E5%85%B9%E5%AE%9E%E9%AA%8C_%E9%A1%B5%E9%9D%A2_12.png" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E5%A4%AB%E5%85%B0%E5%85%8B%E8%B5%AB%E5%85%B9%E5%AE%9E%E9%AA%8C_%E9%A1%B5%E9%9D%A2_13.png" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E5%A4%AB%E5%85%B0%E5%85%8B%E8%B5%AB%E5%85%B9%E5%AE%9E%E9%AA%8C_%E9%A1%B5%E9%9D%A2_14.png" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E5%A4%AB%E5%85%B0%E5%85%8B%E8%B5%AB%E5%85%B9%E5%AE%9E%E9%AA%8C_%E9%A1%B5%E9%9D%A2_15.png" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E5%A4%AB%E5%85%B0%E5%85%8B%E8%B5%AB%E5%85%B9%E5%AE%9E%E9%AA%8C_%E9%A1%B5%E9%9D%A2_16.png" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E5%A4%AB%E5%85%B0%E5%85%8B%E8%B5%AB%E5%85%B9%E5%AE%9E%E9%AA%8C_%E9%A1%B5%E9%9D%A2_17.png" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E5%A4%AB%E5%85%B0%E5%85%8B%E8%B5%AB%E5%85%B9%E5%AE%9E%E9%AA%8C_%E9%A1%B5%E9%9D%A2_18.png" alt=""><br><img src="http://omwttm1sr.bkt.clouddn.com/%E5%A4%AB%E5%85%B0%E5%85%8B%E8%B5%AB%E5%85%B9%E5%AE%9E%E9%AA%8C_%E9%A1%B5%E9%9D%A2_19.png" alt=""></p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;</p>
]]></content>
      
        <categories>
            
            <category> 近代物理实验 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 实验报告 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计算物理几道习题的解法]]></title>
      <url>http://gsjcan.com/2017/03/22/%E8%AE%A1%E7%AE%97%E7%89%A9%E7%90%86%E5%87%A0%E9%81%93%E4%B9%A0%E9%A2%98%E7%9A%84%E8%A7%A3%E6%B3%95/</url>
      <content type="html"><![CDATA[<blockquote>
<p>这几天整理了一下之前计算物理课程的课程报告，现在将其上传到博客里算是学习的一点记录。</p>
</blockquote>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h2><p><img src="http://omwttm1sr.bkt.clouddn.com/%E9%A2%98%E7%9B%AE1.jpg" alt=""></p>
<blockquote>
<p>代码如下： </p>
</blockquote>
<pre><code> #include&quot;stdio.h&quot;
 #include&quot;math.h&quot;
 void main() 
 {
    double f(double x); 
    double T(double x,double y,int z);
    int i,N=500000,N1=3000000,N2=1; 
    double r11,r12,r21,r22,r31=0,r32=0,h,s; 
    r11=0.01;r12=1.0;
    r21=0.01;r22=10.0;
    printf(&quot;\n  已经将实验中的数据(包括上下限)预置于程序内!!\n\n&quot;);    //提示用户
    h=(r12-r11)/N;                                    //计算区间大小
    printf(&quot;  以下为“R1=0.01m、R2=1m”的积分结果：\n &quot;);
    printf(&quot;         取区间数N为:  %d\n\n &quot;,N);        //输出所选择的N值大小
    s=f(r11)*h; 
    for(i=1;i&lt;N;i++) 
    {
      s=s+f(r11+i*h)*h; } 
      printf(&quot;  (1)矩形法求积分值     s=%10.6f\n&quot;,s);  //使用矩形法进行计算
      s=0;
      s=0.5*(f(r11)+f(r11+h))*h; 
      for(i=1;i&lt;N;i++) 
        {
           s=s+0.5*(f(r11+i*h)+f(r11+(i+1)*h))*h;
        } 
      printf(&quot;   (2)梯形法求积分值     s=%10.6f\n&quot;,s);    //使用梯形法进行计算
      s=(4*T(r11,r12,2*N)-T(r11,r12,N))/3.0;  
      printf(&quot;   (3)辛普森法求积分值   s=%f\n&quot;,s);        //使用辛普森法进行计算
      printf(&quot;\n\n&quot;);
      h=(r22-r21)/N1;
      printf(&quot;    以下为“R1=0.01m、R2=10m”的积分结果：\n &quot;);        //输出结果
      printf(&quot;            取区间数N为:  %d\n\n &quot;,N1);
      s=f(r21)*h; 
      for(i=1;i&lt;N1;i++) 
     {s=s+f(r21+i*h)*h; } 
     printf(&quot;  (1)矩形法求积分值    s=%10.6f\n&quot;,s);
     s=0;
     s=0.5*(f(r21)+f(r21+h))*h; 
     for(i=1;i&lt;N1;i++) 
    {
      s=s+0.5*(f(r21+i*h)+f(r21+(i+1)*h))*h;
    } 
    printf(&quot;   (2)梯形法求积分值    s=%10.6f\n&quot;,s);
    s=(4*T(r21,r22,2*N1)-T(r21,r22,N1))/3.0;  
    printf(&quot;   (3)辛普森法求积分值  s=%f\n&quot;,s);
    printf(&quot;\n           (已结束!!)\n\n&quot;);
    while(1)
   {
      printf(&quot;  若需更改其他上下限，请直接输入\n\n&quot;);  //给用户提供改变上下限的功能
      printf(&quot;                      请输入积分值下限 R1= &quot;);
      scanf(&quot;%lf&quot;,&amp;r31);
      printf(&quot;                      请输入积分值上限 R2= &quot;);
      scanf(&quot;%lf&quot;,&amp;r32);
      printf(&quot;                      请输入区间数   N= &quot;);
      scanf(&quot;%d&quot;,&amp;N2);
      h=(r32-r31)/N2;                                     //计算区间大小
      printf(&quot;\n       以下为“R1= %fm、R2= %fm”的积分结果：\n &quot;,r31,r32);
      printf(&quot;            取区间数N为:  %d\n\n &quot;,N2);     //输出所选择的N值大小
      s=f(r31)*h; 
      for(i=1;i&lt;N2;i++) 
      {s=s+f(r31+i*h)*h; } 
      printf(&quot;  (1)矩形法求积分值     s=%10.6f\n&quot;,s);    //使用矩形法进行计算
      s=0;
      s=0.5*(f(r31)+f(r31+h))*h; 
      for(i=1;i&lt;N2;i++) 
      {
        s=s+0.5*(f(r31+i*h)+f(r31+(i+1)*h))*h;
      } 
      printf(&quot;   (2)梯形法求积分值     s=%10.6f\n&quot;,s);   //使用梯形法进行计算
      s=(4*T(r31,r32,2*N2)-T(r31,r32,N2))/3.0;  
      printf(&quot;   (3)辛普森法求积分值   s=%f\n&quot;,s);     //使用辛普森法进行计算
      printf(&quot;\n\n&quot;);
    }
 }
   double f(double r)                   //计算函数值函数
 { 
     double y,n,m,x; 
     n=0.5;
     m=8.854187817*pow(10,-12);
     x=0.01;
     y=n*x*0.5*r/m/pow((x*x+r*r),1.5); 
     return (y); 
 } 
  double T(double x,double y,int z) 
{
    double h,Tn; 
    int i; 
    double f(double t);  
    h=(y-x)/z;  
    Tn=(f(x)+f(y))/2;
    for(i=1;i&lt;z;i++) 
    Tn=Tn+f(x+i*h); 
    Tn=Tn*h; 
    return (Tn);
}
</code></pre><blockquote>
<p>可得到结果如下： </p>
</blockquote>
<p><img src="http://omwttm1sr.bkt.clouddn.com/%E7%A8%8B%E5%BA%8F1%E7%BB%93%E6%9E%9C.jpg" alt=""></p>
<p>&emsp;对比结果：</p>
<p><img src="http://omwttm1sr.bkt.clouddn.com/%E9%A2%98%E7%9B%AE1%E8%A1%A8%E6%A0%BC.jpg" alt=""></p>
<p>&emsp;可以看出，程序所计算误差非常小，并且验证了梯形法和辛普森法比矩形法误差要小的特点。</p>
<p>&emsp;程序初始状态默认首先完全计算不同上下限的不同求法情况，将题目中已给的初始值预置于程序内，并将结果一并输出；若用户需要使用不同的上下限以及区间数N值，在程序计算完第一步后直接输出所需要的值即可。</p>
<h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h2><p><img src="http://omwttm1sr.bkt.clouddn.com/%E9%A2%98%E7%9B%AE2.jpg" alt=""></p>
<blockquote>
<p>代码如下： </p>
</blockquote>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
void main() 
{
 double Y(double t,double y);
 int i;
 double y0=0,y,y1=0,h,t0,t,n,k1,k2,k3,k4;
 y0=0;
 t0=0;
 h=0.1;
 printf(&quot;\n 程序中取步长：h= %2.1f\n&quot;,h);     //输出程序中所预设的步长值
 while(1)                    //while循环结构提供多次计算功能
 {
    printf(&quot;        请输入区间[0,1]上的t值:  &quot;);
    scanf(&quot;%lf&quot;,&amp;t);                          //输入所要计算的数值
    if((t&gt;=0.0)&amp;&amp;(t&lt;=1.0))
    {
        n=t/h;
        for(i=0;i&lt;n;i++)
        {  
            y=y0+Y(t0,y0)*h;           //二级欧拉近似计算
            t0=t0+i*h;
            y1=0.5*(y0+y+Y(t0,y)*h); y0=y1;
        }
        printf(&quot;\n   二级欧拉近似求得t=%lf处函数值 y=   %lf:\n&quot;,t,y1);
        t0=0;y0=0;
        for(i=0;i&lt;n;i++)
        {  
            k1=Y(t0,y0);
            k2=Y(t0+0.5*h,y0+0.5*h*k1);     //龙格库塔法计算
            k3=Y(t0+0.5*h,y0+0.5*h*k2);
            k4=Y(t0+h,y0+h*k3);
            t0=t0+i*h;
            y1=y0+(k1+2*k2+2*k3+k4)*h/6; y0=y1;
        }
        printf(&quot;  龙格库塔法求得t=%lf处函数值 y=   %lf:\n&quot;,t,y1); t0=0;y0=0;
    }
    else
        printf(&quot;     输入t值不在[0，1]范围内!! \n&quot;);
    printf(&quot;\n\n     计算完毕,需要继续计算请直接输入t值!!\n\n&quot;);
  }
}
double Y(double t,double y)   
{                    //计算函数
 double f;
 f=1+exp(-t)*sin(y);
 return f;
}
</code></pre><blockquote>
<p>结果如下： </p>
</blockquote>
<p><img src="http://omwttm1sr.bkt.clouddn.com/%E7%A8%8B%E5%BA%8F2%E7%BB%93%E6%9E%9C.jpg" alt=""></p>
<p>&emsp;程序已预置题中所给的步长值以及导函数、初始条件。提供重复计算的功能，并且若用户输入不在 [0,1]范围内的数值时将做出提示。并且本程序为用户提供了循环多次计算不同t情况下函数值的功能，便于用户多次计算以及检验。</p>
<p>&emsp;由结果可以看出使用二级欧拉近似以及龙格库塔法可以得到不同的结果，理论上龙格库塔法有较高的精度，但实际中由于原函数无法求得，故无法做出误差分析。</p>
<h2 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3"></a>Example 3</h2><p><img src="http://omwttm1sr.bkt.clouddn.com/%E9%A2%98%E7%9B%AE3.jpg" alt=""></p>
<blockquote>
<p>代码如下： </p>
</blockquote>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;math.h&gt;
#define N 100000
float b[4]={4,12,8,34};    //等式右边的得数
float d[4][4]={{5,0,0,0},{0,10,0,0},{0,0,5,0},{0,0,0,10}};      //此即为“D”
float l[4][4]={{0,0,0,0},{-1,0,0,0},{-1,-1,0,0},{-1,-1,-1,0}};  //此即为“L”
float u[4][4]={{0,-1,-1,-1},{0,0,-1,-1},{0,0,0,-1},{0,0,0,0}};  //此即为“U”
float b1[4][4]={0};                                             //此即为“B”
float d1[4]={0};                                                //此即为“d”

float display()
{
 int i,j;
 for(i=0;i&lt;4;i++)
 {
   for(j=0;j&lt;4;j++)
   {
      b1[i][j]=-(l[i][j]+u[i][j])/d[i][i];      //计算矩阵&apos;B&apos; 
   }
   d1[i]=b[i]/d[i][i];                         //计算矩阵&apos;d&apos;
 }
 printf(&quot;矩阵b为：\n&quot;);                        // 输出各矩阵如下
 for(i=0;i&lt;4;i++)
  {
    printf(&quot;%10.3f&quot;,b[i]);
  }
 printf(&quot;\n\n&quot;);
 printf(&quot;矩阵D为：\n&quot;);                       // 输出各矩阵如下
 for(i=0;i&lt;4;i++)
 {
  for(j=0;j&lt;4;j++)
  {
    printf(&quot;%10.3f&quot;,d[i][j]);
  }
  printf(&quot;\n&quot;);
 }
printf(&quot;矩阵L为：\n&quot;);                       // 输出各矩阵如下
for(i=0;i&lt;4;i++)
{

  for(j=0;j&lt;4;j++)
  {
      printf(&quot;%10.3f&quot;,l[i][j]);
  }
  printf(&quot;\n&quot;);
}
printf(&quot;矩阵U为：\n&quot;);                     // 输出各矩阵如下
for(i=0;i&lt;4;i++)
{
 for(j=0;j&lt;4;j++)
 {
  printf(&quot;%10.3f&quot;,u[i][j]);
 }
 printf(&quot;\n&quot;);
}
printf(&quot;矩阵B为：\n&quot;);                     // 输出各矩阵如下
for(i=0;i&lt;4;i++)
{ for(j=0;j&lt;4;j++)
  { printf(&quot;%10.3f&quot;,b1[i][j]); }
  printf(&quot;\n&quot;);
}
printf(&quot;矩阵d为：\n&quot;);                    // 输出各矩阵如下
for(i=0;i&lt;4;i++)
  { printf(&quot;%10.1f&quot;,d1[i]);}
  printf(&quot;\n\n&quot;);
return(0);
}
float calculate()
{
float x1[4]={0},x2[4]={0},temp;
int i=0,j=0,k=0,n=0;
printf(&quot;程序中选定最大迭代数为： N= %d\n\n&quot;,N);         
//将程序中的预设最大迭代数加以说明
while(1)   
//while循环的意义是可提供给用户多次输入初始值的功能，便于检验数据结果正确性
{
    printf(&quot;       请输入初始值x值：\n&quot;);             //提示用户输入初始值
    for(i=0;i&lt;4;i++)
    {
        printf(&quot;                      X%d初始值为:&quot;,i+1);
        scanf(&quot;%f&quot;,&amp;x1[i]);
    }
    for(i=0;i&lt;4;i++)
    { x2[i]=x1[i];}
    while(n&lt;=100000)                              //while循环
    {
        for(i=0;i&lt;4;i++)
        {
            temp=0;
            for(j=0;j&lt;4;j++)
            { temp+=x1[j]*b1[i][j];          //进行迭代，计算 }
            x2[i]=temp+d1[i];
        }
        if((fabs(x2[0]-x1[0])&lt;=0.00001)&amp;&amp;
        (fabs(x2[1]-x1[1])&lt;=0.00001)&amp;&amp;(fabs(x2[2]-x1[2])
        &lt;=0.00001)&amp;&amp;(fabs(x2[3]-x1[3])&lt;=0.00001))  //检验输出条件           
        {
            k=1;
            break;
        }
        else 
        {
            for(i=0;i&lt;4;i++)
            { x1[i]=x2[i]; }
        }
        n++;
    }
    if(k==1)          //若有解，将解输出
    {
        printf(&quot;\n    解得x如下：\n&quot;);
        for(i=0;i&lt;4;i++)
        { printf(&quot; x%d=%9.6f\n&quot;,i+1,x2[i]); }
    }
    else printf(&quot;答案不收敛或初始值不合适,请重试\n&quot;);
    //预设若不能满足收敛则做出提示，重新输入初始值
    printf(&quot;\n 需要更换初始值请直接输入即可!!\n\n&quot;);
}
return(0);
}
void main()
{    
display();   //输出各原始矩阵函数
calculate();  //计算函数
}
</code></pre><blockquote>
<p>结果如下： </p>
</blockquote>
<p><img src="http://omwttm1sr.bkt.clouddn.com/%E7%A8%8B%E5%BA%8F3%E7%BB%93%E6%9E%9C.jpg" alt=""></p>
<p>&emsp;程序已预置方程组，故无需输入各方程系数，选定最大迭代数N=1000000，在迭代过程中若两个迭代的结果相差小于10E-6,则视为解已经稳定，输出结果。</p>
<p>&emsp;在程序中直接输入初始值即可开始自动计算，并且提供重复输入初始值的功能以便于用户检验与分析。</p>
<p>&emsp;在选定初始值分别为：x1=0、x2=14、x3=476、x4=3478的情况下，我们可以得到一下的一组解：</p>
<p><img src="http://omwttm1sr.bkt.clouddn.com/%E9%A2%98%E7%9B%AE3%E8%A1%A8%E6%A0%BC.jpg" alt=""></p>
<p>&emsp;可以看出，使用雅克比迭代法得到的结果非常精确，并且在多次的试验下可以发现初始值的选取几乎不会对结果造成很大的影响。</p>
<h2 id="Example-4"><a href="#Example-4" class="headerlink" title="Example 4"></a>Example 4</h2><p><img src="http://omwttm1sr.bkt.clouddn.com/%E9%A2%98%E7%9B%AE4.jpg" alt=""></p>
<blockquote>
<p>代码如下： </p>
</blockquote>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#define pi 3.1415926
main() 
{   
double fun(double x); 
double fun1(double x);    
int n,i; double x0,x1,x00=0;
x0=pi;  printf(&quot;\n\n\n&quot;);n=10000000;     //最大迭代数
for(i=0;i&lt;n;i++)
{  
 x1=x0-fun(x0)/fun1(x0);
 if(fabs(x1-x0)&gt;=pow(10,-4))
 { x0=x1;}
 else
 { printf(&quot;     x=π时所求根为:%lf\n&quot;,x1); break;} 
 x0=0.5*pi;
 for(i=0;i&lt;n;i++)
 {  
    x1=x0-fun(x0)/fun1(x0);                           //计算，迭代
    if(fabs(x1-x0)&gt;=pow(10,-4))
    { x0=x1;}
    else
    { printf(&quot;  x=π/2时所求根为:%lf\n&quot;,x1); break;     //输出根    }
while(1)
{
    printf(&quot;\n\n  若需采用其它初值，请直接输入：&quot;);      //输入其他初始值
    scanf(&quot;%lf&quot;,&amp;x0);  x00=x0;
    for(i=0;i&lt;n;i++)
    {  
        x1=x0-fun(x0)/fun1(x0);                     //进行迭代计算
        if(fabs(x1-x0)&gt;=pow(10,-4))
        { x0=x1;}
        else
        {
            printf(&quot;\n x=%8.4f时所求根为:%f\n&quot;,x00,fabs(x1)); 
            //由于此函数为奇函数，故正负根一致
            if(x1&lt;=0.00001)
            {
                printf(&quot;\n 解为0，非正根!!\n&quot;);    //若解为0，对用户进行提示
            } break;
        }
    }
}
}
double fun(double x)     //计算函数
{  
 double f; f=sin(x)-0.5*x;
 return f;
}
double fun1(double x)     //计算函数
{   
 double f; f=cos(x)-0.5;
 return f;
}
</code></pre><blockquote>
<p>结果如下： </p>
</blockquote>
<p><img src="http://omwttm1sr.bkt.clouddn.com/%E7%A8%8B%E5%BA%8F4%E7%BB%93%E6%9E%9C.jpg" alt=""></p>
<p>&emsp;程序中已经将题中所给的初始值预置，当两次迭代的结果相差小于10E-4时，视为解已经稳定，自动计算两个初始值下的结果并输出，无需经历选择过程。并且在计算结束后，提供了用户选择其他初始值进行迭代的功能。程序中发现在不同的初始值下，可能出现0、1.895494和-1.895494三种情况，因函数为奇函数，故我们默认将负根视为正根。</p>
<p>&emsp;检验如下：</p>
<p><img src="http://omwttm1sr.bkt.clouddn.com/%E9%A2%98%E7%9B%AE4%E5%85%AC%E5%BC%8F.jpg" alt=""></p>
<p>&emsp;可以看出，使用程序所迭代而得到的结果非常精确，满足要求。</p>
<h2 id="Example-5"><a href="#Example-5" class="headerlink" title="Example 5"></a>Example 5</h2><p><img src="http://omwttm1sr.bkt.clouddn.com/%E9%A2%98%E7%9B%AE5.jpg" alt=""></p>
<blockquote>
<p>代码如下： </p>
</blockquote>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
main() 
{   
 int n=10000000,i; double x0,x1,a,b,r,t,p,e=1,eq=0;
 a=3.592; b=0.04267; r=0.082054; t=500; p=200;
 printf(&quot;\n  -----------------------------------------------------------------\n&quot;);  
 printf(&quot;  -----------------------------------------------------------------\n&quot;);
 printf(&quot;\n\n                     请输入初值x0= &quot;);                                  //一下为输入
 scanf(&quot;%lf&quot;,&amp;x0);        
 for(i=0;i&lt;n;i++)
 {  
    x1=(r*t)/(p+(a/(x0*x0)))+b;                            //迭代公式
    if(fabs(x1-x0)&lt;pow(10,-4))                             //误差限0.0001
    { 
        printf(&quot;\n        误差限为 0.0001 情况下迭代法所求根为:%12.9lf\n\n&quot;,x1);
        eq=(p+a/(x1*x1))*(x1-b)-r*t;                                      //代入检验功能
        printf(&quot;          将此结果代入方程后得结果为：%12.9lf\n&quot;,eq);
        printf(&quot;                (此结果越接近 0，表示所求的根的值越精确!!)\n&quot;);break;
    }
    else x0=x1;
 }
 while(1)        //为用户提供更改初始值以及误差限的功能，便于更精确的计算结果
 {
    printf(&quot;  -----------------------------------------------------------------\n&quot;);
    printf(&quot;  -----------------------------------------------------------------\n&quot;);
    printf(&quot;\n             若需更换初始值以及误差限，请直接输入即可!!\n\n&quot;);
    printf(&quot;                     请输入初值x0= &quot;);                   //输入初始值
    scanf(&quot;%lf&quot;,&amp;x0);    
    printf(&quot;          请输入误差限(例如:0.000001)：ε= &quot;);                //输入误差限
    scanf(&quot;%lf&quot;,&amp;e);
    for(i=0;i&lt;n;i++)
    {  
        x1=(r*t)/(p+(a/(x0*x0)))+b;                               //迭代公式
        if(fabs(x1-x0)&lt;=e)                                         //判断条件
        { 
            printf(&quot;\n        误差限为%12.10lf 情况下迭代法所求根为:%12.9lf\n\n&quot;,e,x1);
            eq=(p+a/(x1*x1))*(x1-b)-r*t;                                    //代入检验功能
            printf(&quot;          将此结果代入方程后得结果为：%12.9lf\n&quot;,eq);
            printf(&quot;                (此结果越接近 0，表示所求的根的值越精确!!)\n&quot;);break;
        }
        else x0=x1;
    }
 }
}
</code></pre><blockquote>
<p>结果如下： </p>
</blockquote>
<p><img src="http://omwttm1sr.bkt.clouddn.com/%E7%A8%8B%E5%BA%8F5%E7%BB%93%E6%9E%9C.jpg" alt=""></p>
<p>&emsp;本程序已将公式中的各常数预置，在此说明程序运行迭代是最大的迭代数N=10000000。</p>
<p>&emsp;本程序还为用户提供了在题目所给的误差限（10E-4）之外更多的选择，用户可以自行输入误差限以及重复输入初始值以便于进行数据检验以及多数据处理。同时在计算得出结果之后，附带了检验的功能，将所得结果代回原方程中，分析结果与0的相近程度，越相近，表示程序所求的根越精确。</p>
<p>&emsp;在选择了不同的误差限下，我们可以得到不同的迭代结果：</p>
<p>ε=10E-4、初值为3时，求得v=0.168182612，代入：<br><img src="http://omwttm1sr.bkt.clouddn.com/%E9%A2%98%E7%9B%AE5%E5%85%AC%E5%BC%8F1.jpg" alt=""></p>
<p>ε=10E-8、初值为2563时，求得v=0.168076832，代入：<br><img src="http://omwttm1sr.bkt.clouddn.com/%E9%A2%98%E7%9B%AE5%E5%85%AC%E5%BC%8F2.jpg" alt=""></p>
<p>&emsp;可以发现，但误差限选择越小的值，所得到的结果越接近0，即精确度越高，程序的迭代效果越好。</p>
<p>&emsp;函数迭代法程序较简单，编写方便，使用于快速进行数据分析。</p>
<h2 id="Example-6"><a href="#Example-6" class="headerlink" title="Example 6"></a>Example 6</h2><p><img src="http://omwttm1sr.bkt.clouddn.com/%E9%A2%98%E7%9B%AE6.jpg" alt=""></p>
<blockquote>
<p>代码如下： </p>
</blockquote>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
double fx[6]={0.2500,0.2268,0.2066,0.1890,0.1736,0};
double sixthcalculate()
{
 double k=0,k0=0,fxx,f53=0,f54=0,f5=0; int n=0,m=0;
 printf(&quot;\n\n       初始值为:\n&quot;);
 for(n=0;n&lt;5;n++)
 {
    printf(&quot;               f(%2.1f)=%7.4f  \n&quot;,n*0.1+1.0,fx[n]);
 } printf(&quot;\n&quot;);
 for(n=0;n&lt;5;n++)          //尝试以三种方式计算各个导数值,并最后求平均值
 {
    k=0;m=0;
    if(n&lt;3)               //判断是否可以使用这种计算方式
    {
        k0=(4*fx[n+1]-3*fx[n]-fx[n+2])/0.2;                 
        k+=k0,m++;
    }
    if(0&lt;n&amp;&amp;n&lt;4)        //判断是否可以使用这种计算方式
    {
        k0=(fx[n+1]-fx[n-1])/0.2;
        k+=k0,m++;
    }
    if(1&lt;n&amp;&amp;n&lt;5)          //判断是否可以使用这种计算方式
    {
        k0=(fx[n-2]-4*fx[n-1]+3*fx[n])/0.2;
        k+=k0,m++;
    }
    fxx=k/m;                        //求平均值
    if(n==3)
        f53=4*fx[4]-fxx*0.2-3*fx[3];    //计算之时x=1.5时的预测函数值
    if(n==4)
        f54=fxx*0.2+fx[3];     //计算之时x=1.5时的预测函数值
    printf(&quot;  f(%2.1f)处的导数值为：%6.4f  \n&quot;,n*0.1+1.0,fxx);
 }
 f5=(f53+f54)/2;  //对所得的f(1.5)的两个预测函数值求平均
 fxx=(fx[3]-4*fx[4]+3*f5)/0.2; 
 //计算x=1.5处的一阶导数值只能使用三点公式的最后一个公式
 printf(&quot;\n   f(1.5)处的&apos;函数值&apos;预测为：%7.4f  \n&quot;,f5);
 printf(&quot;   f(1.5)处的&apos;导数值&apos;预测为：%6.4f  \n\n\n&quot;,fxx);
 return 0;
}

float main()
{
 sixthcalculate();
 return 0;
}
</code></pre><blockquote>
<p>结果如下： </p>
</blockquote>
<p><img src="http://omwttm1sr.bkt.clouddn.com/%E7%A8%8B%E5%BA%8F6%E7%BB%93%E6%9E%9C.jpg" alt=""></p>
<p>&emsp;程序中已经将各初始值预置，并由于前几个数据的导数值可以由多个公式求得，故程序中加入了平均值的方式以求得最佳值。</p>
<p>&emsp;为计算 x=1.5处的导数值，需要求得x=1.5的函数值。此处求f(1.5)并未带入公式（因为公式假设未知），而是使用x=1.3与x=1.4的导数值逆向(预测）推出f(1.5) (同样需要求平均)，进而即可预测求得x=1.5处的一阶导数值。</p>
<blockquote>
<p>与精确值比较：</p>
</blockquote>
<p><img src="http://omwttm1sr.bkt.clouddn.com/%E9%A2%98%E7%9B%AE6%E8%A1%A8%E6%A0%BC.jpg" alt=""></p>
<p>&emsp;可以看出，程序所得结果与精确值相差较小，验证了三点公式的精确度，程序比较成功。但是发现由于f(1.5)的值为预测得出，这给计算x=1.5是的导数值又增加了误差，所以反映到计算结果上F`(1.5)的误差为最大。</p>
<h2 id="Example-7"><a href="#Example-7" class="headerlink" title="Example 7"></a>Example 7</h2><p><img src="http://omwttm1sr.bkt.clouddn.com/%E9%A2%98%E7%9B%AE7.jpg" alt=""></p>
<blockquote>
<p>代码如下： </p>
</blockquote>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include&lt;string.h&gt;
#define N 1000            //此即为“d” 
double  a[8][3]={0};
double  a1[3][3]={0};
double     b[8]={7.82,7.93,7.98,7.99,7.92,7.91,7.80,7.71};
double  b1[3]={0};   //等式右边的得数
double d[3][3]={0};     //此即为“D”
double l[3][3]={0};     //此即为“L”
double u[3][3]={0};     //此即为“U”
double b2[3][3]={0};   //此即为“B”
double d1[3]={0};      //此即为“d” 

double fun(int x)       //计算A^T*A函数
{  
 int i;
 double s=0;
 for(i=0;i&lt;=7;i++)
 s+=pow(i,x); return s;
}
double fun1(int x1)    //计算A^T*y函数
{  
 int i;
 double s=0;
 double     b[8]={7.82,7.93,7.98,7.99,7.92,7.91,7.80,7.71};
 for(i=0;i&lt;=7;i++)
 s+=b[i]*pow(i,x1);  return s;
}
double display()
{
 int i,j;
 printf(&quot;\n\n\n 取拟合多项式为：y=a0+a1x+a2x^2\n\n&quot;);
 printf(&quot; 多项式组成的线性方程组系数矩阵A为:\n&quot;);
 for(i=0;i&lt;8;i++)
 {
    for(j=0;j&lt;3;j++)
    {
        a[i][j]=pow(i,j);   //计算矩阵
        printf(&quot;    %10.3lf&quot;,a[i][j]);
    }
    printf(&quot;\n&quot;);
 }
 printf(&quot;\n 所得正规方程组左系数矩阵A^T*A为:\n&quot;);
 for(i=0;i&lt;3;i++)
 {
    for(j=0;j&lt;3;j++)
    {
        a1[i][j]=fun(i+j);   //计算矩阵A^T*A
        printf(&quot;         %10.3lf&quot;,a1[i][j]);
    }
    printf(&quot;\n&quot;);
 }
 printf(&quot;\n 正规方程组右系数矩阵A^T*y为:\n&quot;);
 for(i=0;i&lt;3;i++)
 {
    b1[i]=fun1(i);                  //计算A^T*y
    printf(&quot;                            %10.3lf&quot;,b1[i]);
    printf(&quot;\n&quot;);                   //输出
 }
 printf(&quot;\n 下面开始用高斯塞德尔迭代法求正规方程组得解:\n&quot;);  
 //使用类似第三题的雅克比迭代法求解方程组
 printf(&quot;\n 矩阵b为：\n&quot;);
 for(i=0;i&lt;3;i++)
 { printf(&quot;    %10.3f&quot;,b1[i]);
 }
 printf(&quot;\n\n&quot;);
 printf(&quot;\n 矩阵D为：\n&quot;);     //输出各矩阵
 for(i=0;i&lt;3;i++)
 {    
    for(j=0;j&lt;3;j++)
    {
        if(i==j)
            d[i][j]=a1[i][j];
        else
            d[i][j]=0;
        printf(&quot;     %10.3f&quot;,d[i][j]);
    }
    printf(&quot;\n&quot;);
 }
 printf(&quot;\n 矩阵L为：\n&quot;);  //输出各矩阵
 for(i=0;i&lt;3;i++)
 {
    for(j=0;j&lt;3;j++)
    {
        if(i&gt;j)
            l[i][j]=a1[i][j];
        else
            l[i][j]=0;
        printf(&quot;     %10.3f&quot;,l[i][j]);
    }
    printf(&quot;\n&quot;);
 }
 printf(&quot;\n 矩阵U为：\n&quot;);         //输出各矩阵
 for(i=0;i&lt;3;i++)
 {
    for(j=0;j&lt;3;j++)
    {
        if(i&lt;j)
            u[i][j]=a1[i][j];
        else
            u[i][j]=0;
        printf(&quot;     %10.3f&quot;,u[i][j]);
    }
    printf(&quot;\n&quot;);
 }
 for(i=0;i&lt;3;i++)  //矩阵B构成//
 {
    for(j=0;j&lt;3;j++)
    {
        b2[i][j]=-(l[i][j]+u[i][j])/d[i][i];
    }
    d1[i]=b1[i]/d[i][i];
 }
 printf(&quot;\n 矩阵B为：\n&quot;);       //输出各矩阵
 for(i=0;i&lt;3;i++)
 {
    for(j=0;j&lt;3;j++)
    {
        printf(&quot;     %10.5f&quot;,b2[i][j]);
    }
    printf(&quot;\n&quot;);
 } 
 printf(&quot;\n 矩阵d为：\n&quot;);         //输出各矩阵
 for(i=0;i&lt;3;i++)
 {
    printf(&quot;      %10.5f&quot;,d1[i]);
 } 
 printf(&quot;\n\n&quot;); return(0);
}
double calculate()
{
 double x1[3]={0},x2[3]={0},temp;
 int i=0,j=0,k=0,n=0;
 while(1)
 {
    printf(&quot;      ---------------------\n&quot;);
    printf(&quot;      ---------------------\n&quot;);
    printf(&quot;                      请输入初值x值：\n\n&quot;);   
    for(i=0;i&lt;3;i++)
    {
        printf(&quot;                      X%d值为: &quot;,i+1);
        scanf(&quot;%lf&quot;,&amp;x1[i]);
    }
    for(i=0;i&lt;3;i++)
    {
        x2[i]=x1[i];
    }
    for(i=0;i&lt;3;i++)
    {
        (double)(x2[i])=(double)(x1[i]);
    }
    while(n&lt;=10000000)
    {
        for(i=0;i&lt;3;i++)
        {
            temp=0;
            for(j=0;j&lt;3;j++)
            {
                if(j!=i)
                {
                    temp+=(double)(x1[j])*(double)(b2[i][j]);
                }
            }
            x1[i]=(double)(temp)+(double)(d1[i]);
        }
 if((fabs(x2[0]-x1[0])&lt;=0.0000001)&amp;&amp;(fabs(x2[1]-x1[1])
 &lt;=0.0000001)&amp;&amp;(fabs(x2[2]-x1[2])&lt;=0.0000001))
    {  
//迭代中，当两次迭代的结果相差小于0.0000001时视为解已经稳定，可以输出
            k=1;break;
    }
        else 
        {
            for(i=0;i&lt;3;i++)
            {
                (double)(x2[i])=(double)(x1[i]);   //交换
            }
        }
        n++;
    }
    if(k==1)
    {
        printf(&quot;\n       解得系数如下：\n\n&quot;);
        for(i=0;i&lt;3;i++)
        {
            printf(&quot;       a%d=%12.7lf\n&quot;,i,x2[i]);
        }
        printf(&quot;\n   即曲线为:\n&quot;);
        printf(&quot;    y=%9.7lf+%9.7lf*x%9.7lf*x*x&quot;,x2[0],x2[1],x2[2]);
    }
    else printf(&quot;答案不收敛或初始值不合适,请重试\n&quot;);
    printf(&quot;\n\n     计算完毕!!需要更换初始值请在下方直接输入\n\n&quot;);     
//此处为用户提供了重复更换初始值的功能，便于用户进行检验与分析数据
 }return(0);
}
main() 
{
 display();    //计算各矩阵并将矩阵输出函数
 calculate();  //雅克比迭代计算函数
}
</code></pre><blockquote>
<p>结果如下： </p>
</blockquote>
<p><img src="http://omwttm1sr.bkt.clouddn.com/%E7%A8%8B%E5%BA%8F7%E7%BB%93%E6%9E%9C.jpg" alt=""></p>
<p>&emsp;本程序已经将题目中所给的数据预置于内，首先由草图可以假设所需要拟合的曲线近视为二次曲线，即设</p>
<p><img src="http://omwttm1sr.bkt.clouddn.com/%E9%A2%98%E7%9B%AE7%E5%85%AC%E5%BC%8F.jpg" alt=""></p>
<p>&emsp;再使用最小二乘法求得正规方程组，然后利用与所学雅克比迭代法类似但又区别的‘高斯-塞德尔’迭代法求出拟设方程的系数，并设置最大迭代数10000000次，程序中默认若在一次迭代中，前后两组数据的差值小10E-7，即视为解已经稳定，输出得数，否则提示用户初始值不佳，需要重试。</p>
<p>&emsp;将初始值设为 x1=8734、x2=0、x3=0.000001时所得结果与精确解比较：</p>
<p><img src="http://omwttm1sr.bkt.clouddn.com/%E9%A2%98%E7%9B%AE7%E8%A1%A8%E6%A0%BC.jpg" alt=""></p>
<p>&emsp;从表中可以看出此程序的计算结果误差非常小，精度较高，完全符合一般情况下的曲线拟合用途。并且在此程序运行时选择的初始值较为极端的情况下，仍然有较小的误差。</p>
<p>&emsp;设计程序之初所用迭代法为雅克比迭代法，但在无数尝试之后发现在迭代过程中 〖x_i〗^(k+1) 始终不收敛，在仍然未想出雅氏迭代法的解决方法的情况下，决定转为使用“高斯-塞德尔”迭代法，并且经过调试之后成功运行。</p>
<p>&emsp;虽然SOR法有更快的收敛速度，但是与高斯法接近，且高斯法已经满足要求，故不用SOR法。</p>
<h2 id="Example-8"><a href="#Example-8" class="headerlink" title="Example 8"></a>Example 8</h2><p><img src="http://omwttm1sr.bkt.clouddn.com/%E9%A2%98%E7%9B%AE8.jpg" alt=""></p>
<blockquote>
<p>代码如下： </p>
</blockquote>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;math.h&gt;
int N=10000000;
int N1=10000000;
double Simpson()          //辛普森法求定积分
{
 int i=0;
 double x=0,y=0,x1=0;
 x1=1/(double)(N);
 for(i=0;i&lt;=N;i++)
 {
    if(i==0||i==N)       //i不同是Ci取不同的值
        y+=1.0/3.0*(1/(1+x*x))*x1;                  
    if((i%2)==0)
        y+=2.0/3.0*(1/(1+x*x))*x1;
    if((i%2)==1)
        y+=4.0/3.0*(1/(1+x*x))*x1;
    x+=x1;
 }
 printf(&quot;\n\n   程序中使用的区间数或投点总数均为：N=10000000\n&quot;);
 printf(&quot;\n     用辛普森法求得定积分为：    %12.8f\n&quot;,y);
 return 0;
}
double Rand1()   //用以产生随机数的函数1
{
 static int x0=4880;   
 //因为随机数产生需要外部函数，故需要设立一个静态局部保证每次调用
 随机数产生函数都能得到不一样的随机数，否则每次的返回结果相同
 int M=87946,L=4534,C=61,x1=0;   
 //此处的各项常数已经由试验后设立为最佳常数(需配合相应的N)检验效果见运行界面
 double R;
 x1=(L*x0+C)%M;    
 R=(double)(x1)/(double)(M);
 x0=x1;
 return R;
}
double Rand2()     //用以产生随机数的函数2
{
 static int x0=6345;    
 //因为随机数产生需要外部函数，故需要设立一个静态局部保证
 每次调用随机数产生函数都能得到不一样的随机数，否则每次的返回结果相同                            
 int M=87946,L=4534,C=61,x1=0;   
 //此处的各项常数已经由试验后设立为最佳常数(需配合相应的N),检验效果见运行界面
 double R;
 x1=(L*x0+C)%M;
 R=(double)(x1)/(double)(M);
 x0=x1;
}
 return R;
double Randway()    //随机掷点法计算定积分
{
 double res,x,y,fx,lx=0,ly=0;
 int i,M=0;
 for(i=0;i&lt;N1;i++)
 {
    x=Rand1(),lx+=x;  
    //选定随机数，并进行累加以最后求平均值用于验证随机性优劣
    y=Rand2(),ly+=y;   
    //为减少两数的联系，设立两个随机函数Rand1()和Rand(2)
    fx=(1.0/(1+x*x));
    if(y&lt;=fx)          //计算
        M++;           //计数
 }
 res=(double)(M)/(double)(N1); //求得定积分
 printf(&quot; 用随机掷点法求得定积分为：    %12.8f\n\n&quot;,res);
 printf(&quot; 产生伪随机数Rand1()的平均值为： %12.8f\n&quot;,lx/(double)(N1));
 printf(&quot; 产生伪随机数Rand2()的平均值为： %12.8f\n\n&quot;,ly/(double)(N1));
 return 0;
}
double function()    //第(2)问使用密度函数求定积分的函数
{
 double fx=0,fx2=0,R1=0,fs,fs2,f0,g0,fxx=0;
 int i;
 for(i=0;i&lt;N1;i++)
 {
    R1=Rand1();             //使用随机数
    fxx=(1/(1.0+R1*R1));    //对应书中的g1(x)函数
    fx+=fxx;
    fx2+=fxx*fxx;                      
 }
 fs=fx/(double)(N1);
 fs2=fx2/(double)(N1);     //方差第一项
 f0=fs2-(fs*fs);           //方差
 g0=sqrt(f0/(double)(N1));   //误差
 printf(&quot;         选概率密度函数为f(x)=1情况下:\n&quot;);
 printf(&quot;   结果为：    %12.8f\n&quot;,fs);
 printf(&quot;   方差为：    %12.8f\n&quot;,f0);
 printf(&quot;   误差为：    %12.8f\n\n&quot;,g0);
 fs=0,fx=0,fx2=0;
 for(i=0;i&lt;N1;i++)
 {
    R1=2-sqrt(4-3*Rand2());  //使用随机数
    fxx=3.0/((1+R1*R1)*(4.0-2*R1));  //对应书中的g1(x)函数
    fx+=fxx;
    fx2+=fxx*fxx;                          
 }
 fs=fx/(double)(N1);
 fs2=fx2/(double)(N1);     //方差第一项
 f0=fs2-(fs*fs);           //方差
 g0=sqrt(f0/(double)(N1));    //误差计算
 printf(&quot;选概率密度函数为f(x)=(1/3)*(4-2*x)情况下:\n&quot;);
 printf(&quot;         结果为：    %12.8f\n&quot;,fs);
 printf(&quot;         方差为：    %12.8f\n&quot;,f0);
 printf(&quot;        误差为：    %12.8f\n\n&quot;,g0);
 printf(&quot;\n\n   (已结束!!) \n\n&quot;);
 return 0;
}
double main()
{
 Simpson();    //辛普森法
 Randway();    //随机掷点法
 function();   //概率密度函数法
 return 0;
}
</code></pre><blockquote>
<p>结果如下： </p>
</blockquote>
<p><img src="http://omwttm1sr.bkt.clouddn.com/%E7%A8%8B%E5%BA%8F8%E7%BB%93%E6%9E%9C.jpg" alt=""></p>
<p>&emsp;辛普森法在第一题中已经运用，此处不赘述。</p>
<p>&emsp;随机掷点法中为产生不同的随机数运用了两个随机数产生函数Rand1()和Rand2()，使用两个函数的目的是为了减少两随机数的联系，为了检验随机数的随机性，对所有的N1（=10000000）个随机数进行累加并求平均值后，与0.5进行比较。需要注意的是，函数产生随机数使用的方法是乘加同余法，其中的常数（λ、C、M）为多次尝试后的结果，此处建议用户在没有更好的解决方案下切勿更改此处的数值。</p>
<p>&emsp;使用概率密度函数的方法重点在于求出g1(x) (=f(x)/g(x)),f(x)为原函数，g(x)为给出的概率密度函数，将变量视为随机数并将随机数代入，即可求得运用此种方法下的解。</p>
<p>&emsp;现将程序解与精确解（π/4）做比较：</p>
<p><img src="http://omwttm1sr.bkt.clouddn.com/%E9%A2%98%E7%9B%AE8%E8%A1%A8%E6%A0%BC.jpg" alt=""></p>
<p>&emsp;可以看出，程序中使用的四种方法精度都很高。采用了随机数的方法中，精度高的原因：一是方法本身已经是成熟的方法，二是因为程序中所设置的随机数随机性好，这从随机性检验中可以看出来。但是由于循环的次数（N）见多，故在处理速度上有一定延迟，这是需要改善的地方。</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;—2016年12月1日。</p>
<pre><code>             122141
          20141000298
             郭少俊
gsjcan@outlook.com/gsj@cug.edu.cn
</code></pre>]]></content>
      
        <categories>
            
            <category> 课程总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 计算初步 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基本软件的高斯峰分离方法]]></title>
      <url>http://gsjcan.com/2017/03/16/%E5%9F%BA%E6%9C%AC%E8%BD%AF%E4%BB%B6%E7%9A%84%E9%AB%98%E6%96%AF%E5%B3%B0%E5%88%86%E7%A6%BB%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<blockquote>
<p>这几天整理了一下之前电子测试技术课程的课程报告，现在将其上传到博客里算是学习的一点记录。</p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;在之前的实验课程学习中，对基本的一些数据处理软件有了初步的了解并掌握了基本的使用方法。一般常用的数据处理软件主要有Origin、Matlab、excel、mathematica。在本次的论文撰写以及对相关文献的查阅过程中，还学习了在谱图分析领域的一款强大的软件—Peakfit。</p>
<p>&emsp;&emsp;对于在本文中讨论的重叠峰分离的问题，使用Origin和Peakfit都能较好的解决，下面将对这两款软件的性能进行初步的对比测试。</p>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><p>&emsp;&emsp;首先，为了使用这两款软件进行重叠峰分离，第一步使用EXCEL软件获取一系列的满足重叠峰曲线的数据点，使用函数语句：</p>
<pre><code>NORMDIST(x,mean,standard_dev,cumulative)
</code></pre><p>&emsp;&emsp;即可得到正太分布的各函数值。选择x值为[0,100],步进为0.01，并使用两次 <code>NORMIDIST()</code> 函数，即完整的语句为：</p>
<pre><code>=1253.31*NORMDIST(x,40,10,0)+ 250.66*NORMDIST(x,60,5,0)
</code></pre><p>&emsp;&emsp;即得函数：</p>
<p><img src="http://omwttm1sr.bkt.clouddn.com/17-3-16/91705880-file_1489671833623_10a7a.jpg" alt=""></p>
<p>&emsp;&emsp;若在该语句后加上：<br>    <code>(1-2*Rand())</code><br>&emsp;&emsp;即可视为加入了本底噪声，噪声范围为±2。</p>
<p>&emsp;&emsp;以式(22)的形式为例，若不加噪声时，将所得到的数据点(大约有10000个)，导入Origin中，使用左下角的曲线拟合即可得到此数据点的初步函数图像如下图所示：</p>
<p><img src="http://omwttm1sr.bkt.clouddn.com/17-3-16/11558064-file_1489671974392_6700.jpg" alt=""></p>
<p>&emsp;&emsp;接着点击图像中的曲线，选择：“analysis-Peaks and Baseline-Peak Analyzer-Open Dialog…”即会出现如下的选项卡：</p>
<p><img src="http://omwttm1sr.bkt.clouddn.com/17-3-16/43916899-file_1489672164152_a7e9.jpg" alt=""></p>
<p>&emsp;&emsp;选择Fit Peak(Pro),并一步步进行，找到峰值点，即可最后拟合出图像。拟合后的图像如下图所示： </p>
<p><img src="http://omwttm1sr.bkt.clouddn.com/17-3-16/29957932-file_1489672232385_16568.jpg" alt=""></p>
<p>&emsp;&emsp;同时，可以在参数表中读出各项参数如下图所示：</p>
<p><img src="http://omwttm1sr.bkt.clouddn.com/17-3-16/55233991-file_1489672280624_c5ae.jpg" alt=""></p>
<p>&emsp;&emsp;若在初始函数中加入噪声，那么我们同样可以得到含有噪声的重叠峰图样，如下图所示：</p>
<p><img src="http://omwttm1sr.bkt.clouddn.com/17-3-16/15968447-file_1489672331717_106b6.jpg" alt=""></p>
<p>&emsp;&emsp;在origin中以相同的步骤进行函数拟合，但注意由于所得到的曲线不光滑，软件无法自动识别出峰值点，故需要在”find peaks”步骤中手动添加峰值点，点击“add”即可，这一步在两高斯峰峰位非常接近时也需要进行。</p>
<p>&emsp;&emsp;在Peakfit里，首先导入数据，确定基底后即可使用“Addl Adjust”进行曲线拟合，此过程需要重复多次，待选项卡中参数“lteration”的值稳定为7时，视为拟合完毕。此时可以通过选项卡查看所拟合函数的参数。</p>
<p>&emsp;&emsp;对曲线进行拟合分离后可以得到如下图所示的图像：</p>
<p><img src="http://omwttm1sr.bkt.clouddn.com/17-3-16/42589501-file_1489672434543_10a4d.jpg" alt=""></p>
<p>&emsp;&emsp;并可以得到拟合函数的各项参数如图所示：</p>
<p><img src="http://omwttm1sr.bkt.clouddn.com/17-3-16/83840514-file_1489672566691_12099.jpg" alt=""></p>
<h2 id="实验结果对比"><a href="#实验结果对比" class="headerlink" title="实验结果对比"></a>实验结果对比</h2><p>&emsp;&emsp;为了更全面地对两款软件进行比较，使用EXCEL软件产生了不含噪声的(A1=50,μ1=40,σ1=10、 A2=20,μ2=60,σ2=5)即峰强比值为5:2和(A1=70,μ1=40,σ1=10、 A2=20,μ2=60,σ2=5) 即峰强比值为7:2以及(A1=70,μ1=50,σ1=10、 A2=20,μ2=60,σ2=5) 即峰强比值为7:2三组数据进行比较。</p>
<p>&emsp;&emsp;得到如下面所示的结果：</p>
<p><img src="http://omwttm1sr.bkt.clouddn.com/chart1.jpg" alt=""></p>
<p>&emsp;&emsp;下一步，同样使用EXCEL软件产生了含噪声的(A1=50,μ1=40,σ1=10、 A2=20,μ2=60,σ2=5)即峰强比值为5:2和(A1=70,μ1=40,σ1=10、 A2=20,μ2=60,σ2=5) 即峰强比值为7:2以及(A1=70,μ1=40,σ1=10、 A2=20,μ2=70,σ2=5) 即峰强比值为5:2三组数据进行比较。</p>
<p>&emsp;&emsp;结果如下表所示： </p>
<p><img src="http://omwttm1sr.bkt.clouddn.com/chart2.jpg" alt=""></p>
<p>&emsp;&emsp;需要说明的是，从表上我们可以看出，Peakfit对于含有较大噪声的谱图是无法快速得到准确结果的。</p>
<p>&emsp;&emsp;软件默认拟合的图像如下图所示：</p>
<p><img src="http://omwttm1sr.bkt.clouddn.com/uselessZAOSHENG.jpg" alt=""></p>
<p>&emsp;&emsp;由图中可以看出，软件默认使用了大量的高斯函数进行拟合，与实验预期所需要的两个高斯峰的条件不符合。出现这类情况的原因主要是因为噪声太大，软件无法自动滤掉该噪声进而自动识别峰值。此时需要进行进一步的多次调试才能得到满意的结果，在此由于时间有限无法进行此项工作。</p>
<p>&emsp;&emsp;从以上图表中可以看到，两款软件的对比之下，Origin 9在本文中所设置的条件下几乎完美地完成了工作，在两重高斯峰所叠加而成的重叠峰情况下，Origin 9 的精确度非常高，各项参数与标准值的误差较小。非常适合于科研工作中对各种能谱或色谱进行快速的分离与分析。</p>
<p>&emsp;&emsp;但同时也应该看到，借助软件进行数据分析，若想得到最佳的结果，那么必须要弄明白软件中采用的分离方法。在本次实验中，由于作者水平有限，无法深入分析 Origin 以及 Peakfit 软件的处理方法，故在本文中无法对其所采用的分离方法进行分析与说明。</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;–2017年1月10日</p>
]]></content>
      
        <categories>
            
            <category> 课程总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 电子测试技术； 高斯峰； </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[欢迎来到我的博客！]]></title>
      <url>http://gsjcan.com/2017/03/14/WELCOME-2017.3.14/</url>
      <content type="html"><![CDATA[<p>Congratulations!</p>
<h2 id="2017年3月14日"><a href="#2017年3月14日" class="headerlink" title="2017年3月14日"></a>2017年3月14日</h2><p>第一篇博文。</p>
<p>因为自己暂时好没想好要写什么，所以空空如也。</p>
<p>暂时博客的页面还比较简陋，有很多不完善的地方，自己也还在摸索，后期等我搞懂了在陆续把其它功能都加上。特别是本地搜索和多说评论，我看了一晚上愣是没看懂。还有不蒜子。</p>
<p>跪求各位前端大佬提供指导。</p>
<p>当然，博客最重要的是内容啦~</p>
<h2 id="2017年3月15日"><a href="#2017年3月15日" class="headerlink" title="2017年3月15日"></a>2017年3月15日</h2><p>今天完成了几个小功能，基本不需要再怎么折腾了。</p>
<ol>
<li>首先把本地的搜索服务给搞好了。讲真，我开始看插件安装看了很久，开始觉得已经配置好了为啥搜索结果还是显示谷歌的内容。后来看配置文件才发现是主题配置文件中的 <code>search: use:</code> 默认为 <code>google</code> ，改成 <code>local</code> 就好了；（好吧，我好像还是没弄好…）</li>
<li>加评论系统的时候，开始打算用多说，但是试了很多次也不行。思考了一下可能我哪里没弄好，也可能是与最近多说老是崩溃有关。所以用了DISQUS，在主题配置文件的 <code>comment:use:</code> 的 <code>use</code> 上填 <code>&quot;disqus&quot;</code> or <code>&quot;disqus_click&quot;</code>,两者区别是后者在页面中不自动加载，不会拖累打开速度（指墙内，仅针对material主题）。墙内不支持disqus,所以想给我评论的小伙伴只能翻墙了，或者，给我发邮件吧；</li>
<li>用了 learncloud 和 Google Analytics；</li>
<li>后期会加上 MathJax 或者 KaTeX, 还没想好用哪个。</li>
<li>这个Hexo里写文章怎么弄二标题…我用markdown语法怎么不行啊。研究研究。</li>
</ol>
<h2 id="2017年3月16号"><a href="#2017年3月16号" class="headerlink" title="2017年3月16号"></a>2017年3月16号</h2><p>搜索好像都有问题。</p>
<p>建议在搜索框输入内容之后直接回车进入搜索结果页面，不要之间点击输入内容后在搜索框下方出现的文章。</p>
<h2 id="2017年4月12日"><a href="#2017年4月12日" class="headerlink" title="2017年4月12日"></a>2017年4月12日</h2><p>搜索功能可以用了。Congratulations!</p>
<p>然后加了一个个人主页。在侧边栏点击关于我选项即可打开。</p>
<p>把页面的图片换了一下，不再是随机产生了。</p>
]]></content>
      
        <categories>
            
            <category> Feelings </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
  
  
    
    <entry>
      <title><![CDATA[About me]]></title>
      <url>http://gsjcan.com/about/index.html</url>
      <content type="html"><![CDATA[<h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><blockquote>
<p><strong>GSJCAN</strong></p>
</blockquote>
<p>GSJ是名字的首字母，can是can <code>[kæn]</code>的意思，表示：可以; 能; 能够; 可能。</p>
<p>目前是物理系大三学生，喜欢尝试新事物。</p>
<h2 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h2><p><strong>主页</strong> : gsjcan.com</p>
<p><strong>Mail</strong>：gsjcan@outlook.com</p>
<p><strong>QQ</strong>： 792616649</p>
]]></content>
    </entry>
    
  
</search>
